import { useState, useEffect, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Container,
  Box,
  Typography,
  Button,
  AppBar,
  Toolbar,
  IconButton,
  Alert,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  useTheme,
  useMediaQuery,
} from '@mui/material';
import { DataGrid, GridColDef, GridRowsProp, GridRowModesModel, GridRowModes, GridActionsCellItem } from '@mui/x-data-grid';
import AddIcon from '@mui/icons-material/Add';
import LogoutIcon from '@mui/icons-material/Logout';
import PictureAsPdfIcon from '@mui/icons-material/PictureAsPdf';
import MenuIcon from '@mui/icons-material/Menu';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import SaveIcon from '@mui/icons-material/Save';
import CancelIcon from '@mui/icons-material/Cancel';
import { useAuth } from '../contexts/AuthContext';
import { Transaction } from '../types';
import api from '../services/api';
import { PDFExportButton } from '../components/PDFExport';

const TransactionTable = () => {
  const { user, logout } = useAuth();
  const navigate = useNavigate();
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
  const isTablet = useMediaQuery(theme.breakpoints.down('md'));
  const [allRows, setAllRows] = useState<GridRowsProp>([]);
  const [rowModesModel, setRowModesModel] = useState<GridRowModesModel>({});
  const [error, setError] = useState('');
  const [selectedMonth, setSelectedMonth] = useState<string>('all');
  const [selectedUser, setSelectedUser] = useState<string>('all');

  const categories = [
    '施設費用',
    '交際費',
    '交際費',
    '事務用品',
    '交通費',
    'その他',
  ];

  const receiptStatuses = [
    'PDF配置済',
    '確認中',
    '未添付',
  ];

  useEffect(() => {
    fetchTransactions();
  }, []);

  // 残金を自動計算する関数
  const calculateBalances = (transactions: Transaction[]): Transaction[] => {
    // 日付でソート
    const sorted = [...transactions].sort((a, b) => {
      const dateA = new Date(a.date);
      const dateB = new Date(b.date);
      return dateA.getTime() - dateB.getTime();
    });

    let currentBalance = 0;
    return sorted.map((transaction) => {
      const deposit = transaction.deposit_from_star || 0;
      const payment = transaction.payment || 0;
      currentBalance += deposit - payment;
      return {
        ...transaction,
        balance: currentBalance,
      };
    });
  };

  const fetchTransactions = async () => {
    const useMockData = import.meta.env.VITE_USE_MOCK_AUTH === 'true';

    if (useMockData) {
      // モックデータ：複数ユーザーのデータ
      const allMockData: Transaction[] = [
        // 山田太郎のデータ
        {
          id: 1,
          date: '2025-09-01',
          deposit_from_star: 400000,
          category: '',
          description: '9月初期残高',
          receipt_status: '',
          user_id: 1,
          user_name: '山田太郎',
        },
        {
          id: 2,
          date: '2025-10-01',
          payment: 13200,
          category: '施設費用',
          description: 'CDアツツキ',
          receipt_status: 'PDF配置済',
          user_id: 1,
          user_name: '山田太郎',
        },
        {
          id: 3,
          date: '2025-10-02',
          payment: 97100,
          category: '施設費',
          description: '10月県立',
          receipt_status: 'PDF配置済',
          user_id: 1,
          user_name: '山田太郎',
        },
        {
          id: 4,
          date: '2025-11-01',
          deposit_from_star: 350000,
          category: '',
          description: '11月分入金',
          receipt_status: '',
          user_id: 1,
          user_name: '山田太郎',
        },
        {
          id: 5,
          date: '2025-11-02',
          payment: 16400,
          category: '施設費',
          description: '11月芦屋公民館',
          receipt_status: 'PDF配置済',
          user_id: 1,
          user_name: '山田太郎',
        },
        // 佐藤花子のデータ
        {
          id: 6,
          date: '2025-09-01',
          deposit_from_star: 300000,
          category: '',
          description: '9月初期残高',
          receipt_status: '',
          user_id: 2,
          user_name: '佐藤花子',
        },
        {
          id: 7,
          date: '2025-10-05',
          payment: 5000,
          category: '交際費',
          description: '10月懇親会',
          receipt_status: 'PDF配置済',
          user_id: 2,
          user_name: '佐藤花子',
        },
        {
          id: 8,
          date: '2025-10-10',
          payment: 8500,
          category: '事務用品',
          description: '文房具購入',
          receipt_status: 'PDF配置済',
          user_id: 2,
          user_name: '佐藤花子',
        },
        {
          id: 9,
          date: '2025-11-01',
          deposit_from_star: 250000,
          category: '',
          description: '11月分入金',
          receipt_status: '',
          user_id: 2,
          user_name: '佐藤花子',
        },
        // 鈴木一郎のデータ
        {
          id: 10,
          date: '2025-10-01',
          deposit_from_star: 200000,
          category: '',
          description: '10月初期残高',
          receipt_status: '',
          user_id: 3,
          user_name: '鈴木一郎',
        },
        {
          id: 11,
          date: '2025-10-15',
          payment: 12000,
          category: '交通費',
          description: '出張費',
          receipt_status: 'PDF配置済',
          user_id: 3,
          user_name: '鈴木一郎',
        },
        {
          id: 12,
          date: '2025-11-05',
          payment: 15000,
          category: '施設費',
          description: '会議室費用',
          receipt_status: 'PDF配置済',
          user_id: 3,
          user_name: '鈴木一郎',
        },
      ];

      // 管理者の場合は全データ、一般ユーザーの場合は自分のデータのみ
      let filteredData = allMockData;
      if (user?.role !== 'admin') {
        // 一般ユーザーの場合は自分のデータのみ（仮にuser_id=1として扱う）
        filteredData = allMockData.filter(t => t.user_name === user?.name);
      }

      // 残金を計算（ユーザーごとに）
      const dataWithBalances = calculateBalances(filteredData);
      setAllRows(dataWithBalances);
      return;
    }

    try {
      const response = await api.get('/transactions');
      // バックエンドで残高が計算されているのでそのまま使用
      setAllRows(response.data);
    } catch (err: any) {
      console.error('API Error:', err);
      // バックエンドが利用できない場合は空のデータを表示
      setAllRows([]);
    }
  };

  // ユーザーのリストを生成（管理者のみ）
  const availableUsers = useMemo(() => {
    if (user?.role !== 'admin') return [];
    const users = new Set<string>();
    allRows.forEach((row: any) => {
      if (row.user_name) {
        users.add(row.user_name);
      }
    });
    return Array.from(users).sort();
  }, [allRows, user?.role]);

  // 月のリストを生成
  const availableMonths = useMemo(() => {
    const months = new Set<string>();
    allRows.forEach((row: any) => {
      if (row.date) {
        const date = new Date(row.date);
        const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
        months.add(monthKey);
      }
    });
    return Array.from(months).sort().reverse();
  }, [allRows]);

  // ユーザー別・月別にフィルタリングされたデータ
  const filteredRows = useMemo(() => {
    let filtered = allRows;

    // ユーザーフィルター（管理者のみ）
    if (user?.role === 'admin' && selectedUser !== 'all') {
      filtered = filtered.filter((row: any) => {
        // 新しい行はフィルターを通過させる
        if (row.isNew) return true;
        return row.user_name === selectedUser;
      });
    }

    // 月フィルター
    if (selectedMonth !== 'all') {
      filtered = filtered.filter((row: any) => {
        // 新しい行はフィルターを通過させる
        if (row.isNew) return true;
        if (!row.date) return false;
        try {
          const date = row.date instanceof Date ? row.date : new Date(row.date);
          if (isNaN(date.getTime())) return false;
          const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
          return monthKey === selectedMonth;
        } catch (e) {
          console.error('Date filter error:', e);
          return false;
        }
      });
    }

    return filtered;
  }, [allRows, selectedMonth, selectedUser, user?.role]);

  const handleAddRow = () => {
    console.log('Adding new row...');
    const newId = `new-${Date.now()}`;
    const today = new Date();
    // 時刻をリセットして日付のみにする
    today.setHours(0, 0, 0, 0);
    const newRow: any = {
      id: newId,
      date: today,
      deposit_from_star: '',
      payment: '',
      category: '',
      description: '',
      receipt_status: '未添付',
      balance: 0,
      isNew: true,
      user_id: user?.id,
      user_name: user?.name || '',
      updated_at: null,
      created_at: null,
    };
    console.log('New row data:', newRow);
    setAllRows([newRow, ...allRows]); // 先頭に追加
    setRowModesModel({
      ...rowModesModel,
      [newId]: { mode: GridRowModes.Edit, fieldToFocus: 'date' },
    });
  };

  const handleSaveRow = async (row: any) => {
    console.log('handleSaveRow called with:', row);
    const useMockData = import.meta.env.VITE_USE_MOCK_AUTH === 'true';

    if (useMockData) {
      // モックモード: ローカルで保存して残金を再計算
      const updatedRows = allRows.map((r: any) => (r.id === row.id ? row : r));
      const withBalances = calculateBalances(updatedRows);
      setAllRows(withBalances);
      return row;
    }

    try {
      // 編集可能なフィールドのみを送信
      // 日付をYYYY-MM-DD形式の文字列に変換
      let dateValue = '';
      if (row.date instanceof Date) {
        dateValue = row.date.toISOString().split('T')[0];
      } else if (typeof row.date === 'string') {
        // 既に文字列の場合、YYYY-MM-DD形式に変換
        const parsedDate = new Date(row.date);
        if (!isNaN(parsedDate.getTime())) {
          dateValue = parsedDate.toISOString().split('T')[0];
        } else {
          dateValue = row.date; // 既に正しい形式の可能性がある
        }
      }

      if (!dateValue) {
        setError('日付を入力してください');
        throw new Error('日付が必要です');
      }

      // 数値フィールドを適切に変換
      const transactionData: any = {
        date: dateValue,
        category: row.category || '',
        description: row.description || '',
        receipt_status: row.receipt_status || '未添付',
      };

      // deposit_from_starとpaymentは値がある場合のみ追加
      if (row.deposit_from_star != null && row.deposit_from_star !== '') {
        const depositValue = Number(row.deposit_from_star);
        if (!isNaN(depositValue)) {
          transactionData.deposit_from_star = depositValue;
        }
      }
      if (row.payment != null && row.payment !== '') {
        const paymentValue = Number(row.payment);
        if (!isNaN(paymentValue)) {
          transactionData.payment = paymentValue;
        }
      }

      console.log('Sending transaction data:', transactionData);

      if (row.isNew) {
        await api.post('/transactions', transactionData);
      } else {
        await api.put(`/transactions/${row.id}`, transactionData);
      }

      // 保存後、全データを再取得して残高を更新
      await fetchTransactions();

      return row;
    } catch (err: any) {
      console.error('Save error:', err);
      setError(err.message || '保存に失敗しました');
      throw err;
    }
  };

  const handleDeleteRow = async (id: number) => {
    const useMockData = import.meta.env.VITE_USE_MOCK_AUTH === 'true';

    if (useMockData) {
      // モックモード: ローカルで削除して残金を再計算
      const updatedRows = allRows.filter((row: any) => row.id !== id);
      const withBalances = calculateBalances(updatedRows);
      setAllRows(withBalances);
      return;
    }

    try {
      await api.delete(`/transactions/${id}`);
      // 削除後、全データを再取得して残高を更新
      await fetchTransactions();
    } catch (err: any) {
      setError('削除に失敗しました');
    }
  };

  const handleEditClick = (id: any) => {
    console.log('Edit clicked for row:', id);
    setRowModesModel({ ...rowModesModel, [id]: { mode: GridRowModes.Edit } });
  };

  const handleSaveClick = (id: any) => {
    console.log('Save clicked for row:', id);
    setRowModesModel({ ...rowModesModel, [id]: { mode: GridRowModes.View } });
  };

  const handleCancelClick = (id: any) => {
    setRowModesModel({
      ...rowModesModel,
      [id]: { mode: GridRowModes.View, ignoreModifications: true },
    });

    const editedRow = allRows.find((row: any) => row.id === id);
    if (editedRow && editedRow.isNew) {
      setAllRows(allRows.filter((row: any) => row.id !== id));
    }
  };

  const handleDeleteClick = async (id: any) => {
    if (window.confirm('この行を削除してもよろしいですか？')) {
      await handleDeleteRow(id);
    }
  };

  const handleLogout = () => {
    logout();
    navigate('/login');
  };

  const columns: GridColDef[] = [
    {
      field: 'user_name',
      headerName: 'ユーザー',
      width: isMobile ? 80 : 120,
      minWidth: 80,
      editable: false,
      hide: user?.role !== 'admin',
    },
    {
      field: 'date',
      headerName: '日付',
      width: isMobile ? 100 : 130,
      minWidth: 90,
      editable: true,
      type: 'date',
      valueGetter: (value) => {
        try {
          if (!value) return null;
          if (value instanceof Date) return value;
          const date = new Date(value);
          return isNaN(date.getTime()) ? null : date;
        } catch (e) {
          console.error('Date valueGetter error:', e, value);
          return null;
        }
      },
    },
    {
      field: 'deposit_from_star',
      headerName: isMobile ? '入金' : 'Starから入金',
      width: isMobile ? 90 : 140,
      minWidth: 80,
      editable: true,
      type: 'number',
      valueFormatter: (value) => {
        try {
          if (value == null || value === '') return '';
          const num = typeof value === 'number' ? value : parseFloat(value);
          return isNaN(num) ? '' : `¥${num.toLocaleString()}`;
        } catch (e) {
          console.error('deposit_from_star valueFormatter error:', e, value);
          return '';
        }
      },
    },
    {
      field: 'payment',
      headerName: '支払い',
      width: isMobile ? 90 : 140,
      minWidth: 80,
      editable: true,
      type: 'number',
      valueFormatter: (value) => {
        try {
          if (value == null || value === '') return '';
          const num = typeof value === 'number' ? value : parseFloat(value);
          return isNaN(num) ? '' : `¥${num.toLocaleString()}`;
        } catch (e) {
          console.error('payment valueFormatter error:', e, value);
          return '';
        }
      },
    },
    {
      field: 'category',
      headerName: '費目',
      width: isMobile ? 100 : 150,
      minWidth: 80,
      editable: true,
      type: 'singleSelect',
      valueOptions: categories,
      hide: isMobile,
    },
    {
      field: 'description',
      headerName: '摘要',
      width: isMobile ? 150 : 300,
      minWidth: 120,
      flex: isMobile ? 0 : 1,
      editable: true,
    },
    {
      field: 'receipt_status',
      headerName: isMobile ? '領収書' : '領収書・請求書',
      width: isMobile ? 80 : 160,
      minWidth: 80,
      editable: true,
      type: 'singleSelect',
      valueOptions: receiptStatuses,
      hide: isMobile,
    },
    {
      field: 'balance',
      headerName: '残金',
      width: isMobile ? 100 : 140,
      minWidth: 90,
      editable: false,
      type: 'number',
      valueFormatter: (value) => {
        try {
          if (value == null || value === '') return '¥0';
          const num = typeof value === 'number' ? value : parseFloat(value);
          return isNaN(num) ? '¥0' : `¥${num.toLocaleString()}`;
        } catch (e) {
          console.error('balance valueFormatter error:', e, value);
          return '¥0';
        }
      },
    },
    {
      field: 'updated_at',
      headerName: '更新日時',
      width: isMobile ? 120 : 160,
      minWidth: 120,
      editable: false,
      type: 'dateTime',
      hide: user?.role !== 'admin',
      valueGetter: (value) => {
        try {
          if (!value) return null;
          if (value instanceof Date) return value;
          const date = new Date(value);
          return isNaN(date.getTime()) ? null : date;
        } catch (e) {
          console.error('updated_at valueGetter error:', e, value);
          return null;
        }
      },
      valueFormatter: (value) => {
        try {
          if (!value) return '';
          const date = value instanceof Date ? value : new Date(value);
          if (isNaN(date.getTime())) return '';
          return date.toLocaleString('ja-JP', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
          });
        } catch (e) {
          console.error('updated_at valueFormatter error:', e, value);
          return '';
        }
      },
    },
    {
      field: 'actions',
      type: 'actions',
      headerName: '操作',
      width: isMobile ? 80 : 120,
      cellClassName: 'actions',
      getActions: ({ id }) => {
        const isInEditMode = rowModesModel[id]?.mode === GridRowModes.Edit;

        if (isInEditMode) {
          return [
            <GridActionsCellItem
              icon={<SaveIcon />}
              label="保存"
              onClick={() => handleSaveClick(id)}
              color="primary"
            />,
            <GridActionsCellItem
              icon={<CancelIcon />}
              label="キャンセル"
              onClick={() => handleCancelClick(id)}
              color="inherit"
            />,
          ];
        }

        return [
          <GridActionsCellItem
            icon={<EditIcon />}
            label="編集"
            onClick={() => handleEditClick(id)}
            color="inherit"
          />,
          <GridActionsCellItem
            icon={<DeleteIcon />}
            label="削除"
            onClick={() => handleDeleteClick(id)}
            color="inherit"
          />,
        ];
      },
    },
  ];

  return (
    <Box sx={{ flexGrow: 1 }}>
      <AppBar position="static">
        <Toolbar variant={isMobile ? 'dense' : 'regular'}>
          <Typography
            variant={isMobile ? 'subtitle1' : 'h6'}
            component="div"
            sx={{ flexGrow: 1 }}
          >
            {isMobile ? 'Star R.G 89' : 'Star R.G 89 経費清算システム'}
          </Typography>
          {!isMobile && (
            <Typography variant="body1" sx={{ mr: 2 }}>
              {user?.name} さん
            </Typography>
          )}
          <IconButton color="inherit" onClick={handleLogout}>
            <LogoutIcon />
          </IconButton>
        </Toolbar>
      </AppBar>

      <Container maxWidth="xl" sx={{ mt: isMobile ? 1 : 3, mb: 3, px: isMobile ? 1 : 3 }}>
        {error && (
          <Alert severity="error" sx={{ mb: 2 }} onClose={() => setError('')}>
            {error}
          </Alert>
        )}

        <Box sx={{
          mb: 2,
          display: 'flex',
          flexDirection: isMobile ? 'column' : 'row',
          gap: isMobile ? 1 : 2,
          alignItems: isMobile ? 'stretch' : 'center',
          flexWrap: 'wrap'
        }}>
          {/* 管理者用：ユーザー選択 */}
          {user?.role === 'admin' && (
            <FormControl sx={{ minWidth: isMobile ? '100%' : 200 }} size={isMobile ? 'small' : 'medium'}>
              <InputLabel>ユーザー</InputLabel>
              <Select
                value={selectedUser}
                label="ユーザー"
                onChange={(e) => setSelectedUser(e.target.value)}
                size="small"
              >
                <MenuItem value="all">全てのユーザー</MenuItem>
                {availableUsers.map((userName) => (
                  <MenuItem key={userName} value={userName}>
                    {userName}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          )}

          {/* 月選択 */}
          <FormControl sx={{ minWidth: isMobile ? '100%' : 200 }} size={isMobile ? 'small' : 'medium'}>
            <InputLabel>表示月</InputLabel>
            <Select
              value={selectedMonth}
              label="表示月"
              onChange={(e) => setSelectedMonth(e.target.value)}
              size="small"
            >
              <MenuItem value="all">全ての月</MenuItem>
              {availableMonths.map((month) => (
                <MenuItem key={month} value={month}>
                  {month.replace('-', '年')}月
                </MenuItem>
              ))}
            </Select>
          </FormControl>

          <Box sx={{ display: 'flex', gap: 1, flexWrap: 'wrap', flex: 1 }}>
            <Button
              variant="contained"
              startIcon={!isMobile && <AddIcon />}
              onClick={handleAddRow}
              size={isMobile ? 'small' : 'medium'}
              fullWidth={isMobile}
            >
              {isMobile ? '+ 追加' : '行を追加'}
            </Button>
            <Button
              variant="outlined"
              startIcon={!isMobile && <PictureAsPdfIcon />}
              component="div"
              size={isMobile ? 'small' : 'medium'}
              fullWidth={isMobile}
            >
              <PDFExportButton
                transactions={filteredRows as Transaction[]}
                userName={user?.name || 'ユーザー'}
                monthPeriod={selectedMonth !== 'all' ? selectedMonth.replace('-', '年') + '月' : undefined}
              />
            </Button>
          </Box>
        </Box>

        <Box sx={{
          height: isMobile ? 'calc(100vh - 280px)' : 600,
          width: '100%',
          bgcolor: 'background.paper',
          overflow: 'auto'
        }}>
          <DataGrid
            rows={filteredRows}
            columns={columns}
            rowModesModel={rowModesModel}
            onRowModesModelChange={(newModel) => {
              console.log('Row modes model changed:', newModel);
              setRowModesModel(newModel);
            }}
            processRowUpdate={(updatedRow, originalRow) => {
              console.log('processRowUpdate called:', { updatedRow, originalRow });
              return handleSaveRow(updatedRow);
            }}
            onProcessRowUpdateError={(error) => {
              console.error('processRowUpdate error:', error);
              setError('データの更新に失敗しました');
            }}
            editMode="row"
            disableRowSelectionOnClick
            density={isMobile ? 'compact' : 'standard'}
            pageSizeOptions={[5, 10, 25, 50, 100]}
            initialState={{
              pagination: {
                paginationModel: { pageSize: isMobile ? 10 : 25 },
              },
            }}
            sx={{
              '& .MuiDataGrid-cell': {
                borderRight: '1px solid rgba(224, 224, 224, 1)',
                fontSize: isMobile ? '0.75rem' : '0.875rem',
                padding: isMobile ? '4px' : '8px',
              },
              '& .MuiDataGrid-columnHeaders': {
                backgroundColor: '#f5f5f5',
                fontWeight: 'bold',
                fontSize: isMobile ? '0.75rem' : '0.875rem',
              },
              '& .MuiDataGrid-row': {
                minHeight: isMobile ? '40px !important' : '52px !important',
              },
              '& .MuiDataGrid-virtualScroller': {
                overflowX: 'auto',
              },
            }}
          />
        </Box>
      </Container>
    </Box>
  );
};

export default TransactionTable;
